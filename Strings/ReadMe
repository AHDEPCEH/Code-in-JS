Постановка задачи:
Дана строка S длины n и строка Т длины m . В дальнейшем,
не оговаривая каждый раз отдельно, будем предполагать, что
n >= m. Будем нумеровать символы строк начиная с 1. Обозначим через S [i.. j], 1 < i < j < n, подстроку строки S, начинающуюся в i-й позиции и заканчивающуюся в j -й позиции. Требуется найти все вхождения строки Т в строку S, т. е. указать все
позиции строки S, начиная с которых читается строка Т. Множество вхождений, которое надо построить, формально описывается так: М = {i:1 < i < n  - m + 1, S[i .. i - m] = Т}.
Вход программы:
На вход передаётся название выполняемой программы:
-bf.js (Считает простым перебором все вхождения)
-bf_hash.js (Считает хеши всех подстрок и ищет перебором подходящие)
-bf_hash_exp.js (Считает сумму квадратов всех символов подстрок, и ищет перебором подходящие)
-bf_hash_rk.js (Сумма хешей ввычисляется по формуле Рабина и Карпа, и перебором ищет подходящие)
Выход программы:
1)В первой строке программа выводит время выполнения алгоритма поиска заданной подстроки.
2)Далее программа выводит массив с номерами всех точек вхождения (с учётом того, что первой символ строки S нумеруется 1).
3)В конце выводится количество найденных вхождений.
Результаты вычислений:
Поиск подстроки 'князь' в первом томе "Война и Мир"
bf.js - 7.835ms 
bf_hash.js - 18.301ms
bf_hash_exp.js - 18.443ms
bf_hash_rk.js - 26.418ms
Поиск подстроки 'князь Андрей' в первом томе "Война и Мир"
bf.js - 11.328ms 
bf_hash.js - 17.798ms
bf_hash_exp.js - 21.738ms
bf_hash_rk.js - 26.022ms
Таким образом можно заметить, что программы с вычислением хеша работают медленнее, чем обычный перебор, однако:
Поиск подстроки 'aaaaaab' в строке: 'a' * 1032931
bf.js - 27.136ms 
bf_hash.js - 12.348ms
bf_hash_exp.js - 15.154ms
bf_hash_rk.js - 99.246ms
Поиск подстроки 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab' в строке: 'a' * 1032931
bf.js - 118.241ms
bf_hash.js - 12.582ms
bf_hash_exp.js - 15.116ms
bf_hash_rk.js - 102.181ms
Можно сделать вывод:
Метод грубого перебора работает достаточно быстро при некоторых условиях, в худшем случае O(n*m)
Методы хеширования исключая алгоритм (Робина и Карпа), работают практически не изменяя свою скорость в зависимости от строки, в худшем случае O(n + mn - m^2)
Метод хеширования используя алгорим Робина и Карпа, работает медленно, хоть и исключает большинство коллизий, проблемой является возведение в степень хешей отдельных символов, сложность O(n/2 * m^2)
Стоит упомянуть, что скорость вычислений зависит от характеристик системы.
Тесты проводились:
Процессор: AMD Ryzen 7 3700X
Количество RAM: 16Gb
ОС: Windows 11 x64